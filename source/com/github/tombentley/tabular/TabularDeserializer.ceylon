import ceylon.language.meta {
    type,
    typeLiteral
}
import ceylon.language.meta.model {
    Class,
    MemberClass,
    ClassModel,
    Type
}
import ceylon.language.meta.declaration {
    ClassDeclaration,
    ValueDeclaration,
    TypeParameter,
    Module
}
import ceylon.language.serialization {
    Deconstructed,
    Reference,
    DeserializableReference,
    RealizableReference,
    DeserializationContext,
    deserialization
}
import ceylon.collection {
    ArrayList,
    HashMap
}
"Determine whether `a` is a subclass of `b`."
Boolean isSubclassOf(ClassDeclaration a, ClassDeclaration b) {
    variable ClassDeclaration? aSuper = a;
    while (exists aSup = aSuper) {
        if (aSup == b) {
            // a is a subclass of b
            return true;
        }
        aSuper = aSup.extendedType?.declaration;
    }
    return false;
}

"Provides a facility for deserializing instances from String previously 
 generated by [[TabularSerializer]]."
shared class TabularDeserializer(Module mod, String serialized) {
    
    DeserializationContext context = deserialization();
    
    "A map from class to table. This must have iteration order such that 
     more derived classes occur before their super classes, so that 
     [[idToCd]] gets populated with the instance class for a given id 
     (rather than some superclass of the instance)."
    HashMap<ClassDeclaration,AttributeTable> tables = HashMap<ClassDeclaration,AttributeTable>();
    
    "A map from instance id to the tables in which its state is stored. 
     The tables are in most-refined to least refined order."
    HashMap<Id,ClassDeclaration> idToCd = HashMap<Id,ClassDeclaration>();
    
    value reader = LineReader(serialized.iterator().next);
    MetaTableReader mtr = MetaTableReader(reader);
    MetaD metaTable = mtr.read();
    value parser = mtr.parser;
    value arrayTable = ArrayTableReader(parser, metaTable, reader).read();
    void readAttributeTables(LineReader reader) {
        
        AttributeTableReader atr = AttributeTableReader(reader, parser, metaTable);
        value tableList = ArrayList<AttributeTable>();
        // read the tables from the stream
        while (exists table = atr.read()) {
            // insert tables into the list so more refined tables occur 
            // before less refined, so when we iterate tables we associate 
            // each id in the stream woth the most derived class.
            variable value index = 0;
            for (t in tableList) {
                ClassDeclaration cd = metaTable.classDeclaration(t.classDeclaration);
                ClassDeclaration cd2 = metaTable.classDeclaration(table.classDeclaration);
                if (isSubclassOf(cd, cd2)) {
                    tableList.insert(index + 1, table);
                    break;
                } else if (isSubclassOf(cd2, cd)) {
                    tableList.insert(index, table);
                    break;
                }
                
                index++;
            } else {
                tableList.add(table);
            }
        }
        
        // Finally iterate those tables, populating idToTables
        for (table in tableList) {
            ClassDeclaration cd = metaTable.classDeclaration(table.classDeclaration);
            
            if (exists existingTable = tables.put(cd, table)) {
                throw Exception("multiple tables for ``cd``");
            }
            // TODO can speed up this loop if I know table is abstract
            for (id in table.rows.keys) {
                if (!id in idToCd.keys) {
                    idToCd.put(id, cd);
                }
            }
        }
    }
    
    readAttributeTables(reader);
    
    "The class of the serialized instance with the given id"
    ClassModel<Instance,Nothing> classOf<Instance,Outer = Anything>(Id id) {
        if (exists aa = arrayTable.rows.get(id)) {
            Type<Anything> ta = metaTable.type<Anything>(aa.typeArgument);
            return `class Array`.classApply<Instance,Nothing>(ta);
        } else if (exists cd = idToCd[id]) {
            if (exists table = tables[cd]) {
                if (exists row = table.get(id)) {
                    if (exists outr = row.outerInstance) {
                        value outerClass = classOf<Outer>(outr); //metaTable.type<Outer>(outr);
                        return cd.memberClassApply<Outer,Instance,Nothing>(
                            outerClass,
                            *row.typeArguments.map(metaTable.type<Instance>));
                    } else {
                        return cd.classApply<Instance,Nothing>(*row.typeArguments.map(metaTable.type<Anything>));
                    }
                }
            }
            throw Exception("type arguments not found for ``cd`` with id ``id``");
        } else {
            throw Exception("id not found in idToCd: ``id``");
        }
    }
    void registerReferences() {
        
        for (id->row in arrayTable.rows) {
            assert (is Class<Anything> c = classOf<Anything>(id));
            context.reference(id, c);
        }
        
        for (id->cd in idToCd) {
            value c = classOf<Anything,Nothing>(id);
            if (is Class<Anything> c) {
                context.reference(id, c);
            } else if (is MemberClass<Anything,Anything> c) {
                Reference<Anything> outerRef = nothing;
                context.memberReference(id, c, outerRef);
            }
        }
    }
    
    
    "Get a Deconstructed for the instance with the given id, of the given class"
    List<AttributeTable> getState(Id id, ClassModel clazz) {
        
        variable value classDecl = idToCd[id];
        // TODO This List<Table> is not necessary: TabDeconstructed can just follow the
        // link tables[table.superClass] to get the superclass table. Or at least make this return an Iterable
        ArrayList<AttributeTable> tabs = ArrayList<AttributeTable>();
        while (exists cd = classDecl,
            cd != `class Object` && cd != `class Basic`) {
            assert (exists t = tables[cd]);
            tabs.add(t);
            if (exists s = t.superModel) {
                classDecl = metaTable.classDeclaration(s);
            } else {
                classDecl = null;
            }
        }
        return tabs;
    }
    
    // register references with the context
    registerReferences();
    
    // now deserialize the references
    for (reference in context) {
        assert (is DeserializableReference<Anything> reference);
        /* XXX DeserializationContext should be Iterable<StatelessReference>?
         or does an element change to StatefulReference once deserialize() 
         has been called? */
        assert (is Id id = reference.id);
        
        class TabDeconstructed() satisfies Deconstructed {
            value arrayRow = arrayTable.rows.get(id);
            List<AttributeTable> tabs = getState(id, reference.clazz);
            
            Instance|Reference<Instance> valueOrReference<Instance>(Anything val) {
                if (is Id val) {
                    // Is it an object? 
                    if (exists vd = metaTable.objectDeclaration(val)) {
                        //print("`` vd.get() else "null" ``  (``type(vd.get())``) ``typeLiteral<Type>()``");
                        assert (is Instance r = vd.get());
                        if (exists r,
                            r.string.startsWith("ceylon.language.null_@")) {
                            assert (is Instance f = null);
                            return f;
                        }
                        return r;
                    }
                    value c = classOf<Instance>(val);
                    if (is Class<Instance> c) {
                        return context.reference(val, c);
                    } else if (is MemberClass<Anything,Instance> c) {
                        Reference<Anything> outerRef = nothing;
                        return context.memberReference(val, c, outerRef);
                    } else {
                        throw Exception();
                    }
                    //return context.reference(val, classOf<Instance>(val));
                } else if (is Instance val) {
                    return val;
                } else {
                    throw Exception("type(val): ``type(val)`` Type:``typeLiteral<Instance>()``");
                }
            }
            
            shared actual String string => "deconstructed state of ``id`` ``reference.clazz``";
            
            shared actual Reference<Instance>? getOuterInstance<Instance>() {
                return nothing;
            }
            
            shared actual Instance|Reference<Instance> getValue<Instance>(ValueDeclaration attribute) {
                if (exists arrayRow) {
                    value size = arrayRow.size;
                    assert (is Instance|Reference<Instance> size);
                    return size;
                } else {
                    for (table in tabs) {
                        try {
                            ClassDeclaration cd = metaTable.classDeclaration(table.classDeclaration);
                            if (cd == attribute.container) {
                                assert (exists row = table.get(id));
                                value val = row.getValue(attribute);
                                
                                return valueOrReference<Instance>(val);
                            }
                        } catch (Throwable e) {
                            throw Exception("id=``id``, vd=``attribute``, table=``table``", e);
                        }
                    }
                    throw Exception("attribute not found: ``attribute`` in ``tabs``");
                }
            }
            
            shared actual Instance|Reference<Instance> getElement<Instance>(Integer index) {
                assert (exists arrayRow);
                try {
                    value val = arrayRow.getValue(index);
                    return valueOrReference<Instance>(val);
                } catch (Throwable e) {
                    throw Exception("id=``id``, index=``index``, arrayRow=``arrayRow``", e);
                }
            }
            
            shared actual Type getTypeArgument(TypeParameter typeParameter) {
                if (exists arrayRow) {
                    return metaTable.type(arrayRow.typeArgument);
                }
                for (table in tabs) {
                    ClassDeclaration cd = metaTable.classDeclaration(table.classDeclaration);
                    if (cd == typeParameter.container) {
                        assert (exists row = table.get(id));
                        Id taId = row.getTypeArgument(typeParameter);
                        value ta = metaTable.type(taId);
                        //print("``typeParameter`` has type argument ``ta``");
                        return ta;
                    }
                }
                throw Exception("type parameter not found: ``typeParameter`` in tables ``tables`` for id ``id``  clazz ``reference.clazz``");
            }
            
            shared actual Iterator<[ValueDeclaration, Anything]> iterator() {
                object iter satisfies Iterator<[ValueDeclaration, Anything]> {
                    
                    Iterator<AttributeTable> titer = tabs.iterator();
                    variable Iterator<ValueDeclaration> vds = emptyIterator;
                    variable AttributeTable.Row? row = null;
                    
                    shared actual [ValueDeclaration, Anything]|Finished next() {
                        variable value nextVd = vds.next();
                        while (is Finished vd = nextVd) {
                            value table = titer.next();
                            if (!is Finished table) {
                                row = table.get(id);
                                vds = table.columns.iterator();
                                nextVd = vds.next();
                            } else {
                                return finished;
                            }
                        }
                        assert (is ValueDeclaration vd = nextVd);
                        assert (exists r = row);
                        return [vd, getValue<Object?>(vd)];
                    }
                }
                return iter;
            }
        }
        reference.deserialize(TabDeconstructed());
    }
    
    // END OF INITIALIZER
    
    // API for the client to get some deserialized instances
    shared {Type*} select<Type>(ClassModel<Type> from) {
        /*{RealizableReference<Object?>*} statefulRefs = context.map(function(Reference<Object?> reference) {
                assert (is RealizableReference<Object?> reference);
                return reference;
            });*/
        //print(context);
        {Reference<Anything>*} refs = context.filter(function(Reference<Anything> reference) {
                
                value sub = reference.clazz.subtypeOf(from);
                //print("``reference.clazz`` subtype of ``from`` ? ``sub``");
                return sub;
            });
        return refs.map(function(Reference<Anything> reference) {
                //print("reference: ``reference``");
                assert (is RealizableReference<Anything> reference);
                value instance = reference.instance();
                //print("reference2: ``reference``");
                //print("instance: `` instance else "null" `` (``type(instance)``)");
                //print("Type: ``typeLiteral<Type>()``");
                if (is Type instance) {
                    //print("instance2: `` instance else "null" ``");
                    return instance;
                } else {
                    throw Exception("expected Type, but got `` instance else "null" `` (``type(instance)``) ``typeLiteral<Type>()``");
                }
            });
    }
}
